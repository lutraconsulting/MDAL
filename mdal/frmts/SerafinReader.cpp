// Reader for files 2D/3D generated by The  TELEMAC modelling system
// Module initially developped by herve ozdoba - Sept 2008 ( herve-externe.ozdoba at edf.fr / herve at ozdoba.fr )

#include "FFileReader.h"
#include "SerafinReader.h"

#include <iostream>  // use cerr

/** +++++++++++++++++ Definition des methodes de la classe FFileReader +++++++++++++++++ **/

/* ******************* Constructeur *******************
 * Ce constructeur recoit un flux de lecture de fichier en argument .
 * Gloabalement, les initialisations sont effectuee ici et le premier entier est lu pour
 * determiner dans quelle configuration d'ecriture on se place en association avec le fichier .
 * La differenciation petit/grand boutien est faite a la lecture du premier entier 
 * qui doit valoir la taille maximale du titre soit 80 caracteres.
 */
FFileReader :: FFileReader(ifstream* stream)
{
    // differentes initialisations
    this->BigEndian  = false ;
    this->BlocSize	 = 0 ;
    this->FileStream = stream;
    this->FloatSize  = sizeof(float);

    // lecture de l'entete
    readBlocSize ();
    if (this->BlocSize != TITLE_MAX_SIZE) // pas d'echange d'octet a la lecture
    {
        this->BigEndian = true ;
        // Relecture de l'entete
        readBlocSize ();
        }
        
        FFileReader::readIntArray   = &FFileReader::g_readInt32Array   ;
        FFileReader::readFloatArray = &FFileReader::g_readFloat32Array ;
        /**********
         * need to check the size of float variables somewhere
         * 
         * first float variable is coordinates but class nos nothing about file structure
         * 
         * So need to do this elsewhere but allow to reset the read functions from outside
         ************/ 
}

/* Lecture d'un tableau d'entier arr de taille size avec inversion de octets */
int64_t FFileReader :: s_readInt32Array(int* arr, const int size)
{
    FileStream->read ((char*)(arr), sizeof(int)*size);
    Swap32Array (size, (char*)(arr));
    return FileStream->tellg();
}

/* Lecture d'un tableau d'entier arr de taille size sans inversion de octets */
int64_t FFileReader :: ns_readInt32Array(int* arr, const int size)
{
    FileStream->read ((char*)(arr), sizeof(int)*size);
    return FileStream->tellg();
}

/* Lecture d'un tableau de flottants arr de taille size avec inversion de octets */
int64_t FFileReader :: s_readFloat32Array(float* arr, const int size)
{
    FileStream->read ((char*)(arr), sizeof(float)*size);
    Swap32Array (size, (char*)(arr));
    return FileStream->tellg();
}

/* Lecture d'un tableau de flottants arr de taille size sans inversion de octets */
int64_t FFileReader :: ns_readFloat32Array(float* arr, const int size)
{
    FileStream->read ((char*)(arr), sizeof(float)*size);
    return FileStream->tellg();
}
// generic single entry read functions
int64_t FFileReader :: g_readInt32Array(int* arr, const int size)
{
    FileStream->read ((char*)(arr), sizeof(int)*size);
    if ( this->BigEndian ) {
        Swap32Array (size, (char*)(arr));
    }
    return FileStream->tellg();
}

int64_t FFileReader :: g_readFloat32Array(float* arr, const int size)
{
    FileStream->read ((char*)(arr), sizeof(float)*size);
    if ( this->BigEndian ) {
        Swap32Array (size, (char*)(arr));
    }
    return FileStream->tellg();
}

/* ******************* Destructeur ***************** */
// TODO completer cette methode !!!
FFileReader :: ~FFileReader()
{
    // Ne rien faire pour le moment
}

/** +++++++++++++++++ Definition des methodes de la classe SerafinReader +++++++++++++++++ **/

/* ******************* Constructeur ***************** */
SerafinReader :: SerafinReader(ifstream* stream) : FFileReader(stream)
{
    // TODO Initialisation des variables
    this->metadata  = new SerafinMetaData();
    this->index	= new SerafinIndexInfo();
    
    // Lecture des metadonnee
    this->readMetaData ();
    
    //Creation de l'index
    this->createIndex ();
}

/* ******************* Destructeur ***************** */
// TODO completer cette methode !!!
//SerafinReader :: ~SerafinReader()
//{
//  // Ne rien faire pour le moment, provoque une 'legere fuite memoire' maitrisee
//};

/* ******************* createIndex ***************** */
/* Cette methode cree un index de taille et de position a partir des informations meta 
 * afin de faciliter la lecture du fichier serafin .
 */
void SerafinReader :: createIndex ()
{
    int testVolFin = 0 ;
    
    this->index->FileSize = GetFileSize();
    this->index->MetaSize = FileStream->tellg();	
    
    // Taille du fichier - taille des metadonnees - IPOBO - IKLE - table de X - table de Y
    this->index->DataSize 		= (index->FileSize) - (index->MetaSize) - 3 * (4*GetNumberOfNodes()+8) - (4*GetNodeByElements()*GetNumberOfElement()+8);
    this->index->DataPosision 	= (index->FileSize) - (index->DataSize);
    
    /*............................................................................................*/
    
    // Nombre de variables * nombre de points si le fichier est  en ElFin
    // Nombre de variables * nombre d'elements si le fichier est en VolFin 

    if (!Is3Dfile ()) FileStream->seekg( this->index->DataPosision + 12                             , std::ios_base::beg ); 
    else              FileStream->seekg( this->index->DataPosision + 12 + (8+GetNumberOfNodes()*4)  , std::ios_base::beg );
    //[ci dessus] Si c'est en 3D, on zappe les valeurs de Z pour obtenir la taille d'un bloc de donnees de discretisation
        
    (*this.*readIntArray)(&testVolFin, 1);
    
    if (GetNumberOfNodes()*4 == testVolFin) // Si c'est un fichier ElFin
    {
        this->index->discretizationtype = P0_Elem;
        this->index->DataBlocSize       = GetNumberOfVars()*(8 + GetNumberOfNodes() * 4) + 12 ;
        
    }
    else if (GetNumberOfElement()*4 == testVolFin) // Si c'est un fichier Volfin
    {
        this->index->discretizationtype = P1_Elem;
        
        // TODO A supprimer, pas de fichier volfin en 3D !!!!!!!!!!
        this->index->DataBlocSize   = (!Is3Dfile ()) 
            ?  GetNumberOfVars()    * (8 + GetNumberOfElement() * 4) + 12 
            : (GetNumberOfVars()-1) * (8 + GetNumberOfElement() * 4) + 12 + (8 + GetNumberOfNodes() * 4) ;
    }
    else return;
    
    this->index->ConnectivityPosition   = this->index->MetaSize;
    this->index->XPosition = (index->MetaSize) +     (4*GetNumberOfNodes()+8) + (4*GetNodeByElements()*GetNumberOfElement()+8);
    this->index->YPosition = (index->MetaSize) + 2 * (4*GetNumberOfNodes()+8) + (4*GetNodeByElements()*GetNumberOfElement()+8);
    
    this->index->NumberOfDate = (index->DataSize)/(index->DataBlocSize);

}

/* ******************* readMetaData ***************** */
/* Cette methode permet de de lire les metadata dans le but de recueillir les informations
 * essentielles incluses dans le fichier . Globalement, la demarche sequentielle est la suivante :
 *  -  lecture du titre et suppression des espaces en fin de chaine s'il y en a 
 *  -  lecture du nombre de variables
 *  -  lecture du nom des variables et des leurs unites respectives
 *  -  lecture des paramametres
 *  -  lecture des informations de discretisation
 */
int SerafinReader :: readMetaData ()
{
    
    //Lecture du titre
    if (ReadString(metadata->Title, TITLE_MAX_SIZE) != 88) return 0;
    //extraction du format (caracteres 73-80)
    strncpy(metadata->TitleFormat, &metadata->Title[72], TITLE_FORMAT);
    DeleteBlank(metadata->Title, TITLE_MAX_SIZE-8);
    DeleteBlank(metadata->Title, TITLE_FORMAT);
    
    //lecture du nombre de variables (on passe les entete)
    skipReadingHeader(FileStream);   //skip reclen
    // read linear varsno 
    if ((*this.*readIntArray)(&(metadata->VarNumber), 1) != 96) return 0;
    skipReadingHeader(FileStream);  // skip quad varno
    skipReadingHeader(FileStream);  // skip reclen
    
    //lecture des variables
    // TODO recommencer les controles de position a partir d'ici
    metadata->VarList = (char *)new SerafinVar[metadata->VarNumber];
    metadata->nVarList = new SerafinVar[metadata->VarNumber];
        
        
    {
        char buffer[VAR_DESC_SIZE*2];
        for( int compteur = 0; compteur < metadata->VarNumber ; compteur++)
        {
//          ReadString(metadata->VarList+compteur*VAR_DESC_SIZE*2, VAR_DESC_SIZE*2);
                        // must read full buffer as each varaible is a file record 
            ReadString(&buffer[0], VAR_DESC_SIZE*2);
            strncpy(metadata->nVarList[compteur].name, &buffer[0], VAR_DESC_SIZE);
            strncpy(metadata->nVarList[compteur].unit, &buffer[VAR_DESC_SIZE], VAR_DESC_SIZE);
            metadata->nVarList[compteur].name[15]=0;
            metadata->nVarList[compteur].unit[15]=0;
        }
    };

    // Lecture des parametres et, si necessaire, de la date de simu
    skipReadingHeader(FileStream);
    (*this.*readIntArray)(metadata->IParam, PARAM_NUMBER);
    skipReadingHeader(FileStream);
    if (metadata->IParam[9] == 1)// Si la date est indiquee
    {
        skipReadingHeader(FileStream);
        (*this.*readIntArray)(metadata->Date, DATE_NUMBER);
        skipReadingHeader(FileStream);
    };
        
    //lecture des information de discretisation
    skipReadingHeader(FileStream);
    (*this.*readIntArray)(metadata->DiscretizationInfo, DISC_DESC_SIZE);
    skipReadingHeader(FileStream);
    
    // On lit l'entete du bloc de lecture pour connaitre la taille de la table de connectivite
    if (IsBigEndian()) s_readBlocSize ();else  ns_readBlocSize ();
        
    return FileStream->tellg();
}

